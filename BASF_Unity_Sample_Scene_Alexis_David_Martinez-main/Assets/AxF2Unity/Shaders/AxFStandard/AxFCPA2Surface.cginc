// Copyright (c) 2021 Steinbeis-Forschungszentrum Computer Graphik und Digitalisierung

#ifndef AXFCPA2SURFACE_CGINC
#define AXFCPA2SURFACE_CGINC

#include "UnityCG.cginc"
#include "UnityStandardConfig.cginc"
#include "UnityPBSLighting.cginc" // TBD: remove
#include "UnityStandardUtils.cginc"

#include "AxFCPA2Properties.cginc"
#include "UVTiling.cginc"

// require:
// REQUIRE_TANGENT_TO_WORLD


float2 TransformMainTexCoords(float2 uv0)
{
    // Always source from uv0
    return TRANSFORM_TEX(uv0, _SimpleFlakesColorMap);
}


struct SurfaceInput
{
    float3 positionWS;
    float3 viewDirWS;
    float2 uvMain;
    bool isFrontFace;
    float3x3 tangentToWorld;
};

float3 TangentToWorld(SurfaceInput input, float3 normalTS)
{
    return mul(normalTS, input.tangentToWorld);
}

half ClearCoatReflectance(half3 normal, half3 viewDir, half F0, half F90)
{
    half nv = saturate(dot(normal, viewDir));
    half refl = FresnelLerp(F0, F90, nv).x;
    return refl;
}

struct SurfaceData
{
    float2 uv;
    float2 duvdx;
    float2 duvdy;

    float3 DiffuseColor;
    float3 SpecularColor;

    float DiffuseFGD;

    float GGXSmoothness;
    float GGXFGD;

    float4 CTCoeffs;
    float4 CTF0s;
    float4 CTSpreads;
    float CTFGD;

    float IBLSmoothness;

    float3 FlakesColor;
    float FlakesSmoothness;
    float FlakesFGD;

    float3 NormalWS;

#ifdef CLEAR_COAT
    float ClearCoatF0;
    float ClearCoatF90;
    float ClearCoatIOR;
    float ClearCoatReflectance;
#endif // CLEAR_COAT

    float Occlusion;
    float3 Emission;
};


#ifdef USE_FULL_COLOR_LUT_POINT_LIGHTS
float3 SampleBRDFColorLUT(float NdotH_below, float HdotL_below)
{
    float theta_f = acos(clamp(NdotH_below, 0, 1));
    float theta_i = acos(clamp(HdotL_below, 0, 1));

    float2 uv = float2(theta_f, theta_i) / (0.5 * UNITY_PI);
    uv += 0.5*_BRDFColorLUT_TexelSize.xy;
    return UNITY_SAMPLE_TEX2D_LOD(_BRDFColorLUT, uv, 0).xyz;
}
#endif // USE_FULL_COLOR_LUT_POINT_LIGHTS


#ifdef USE_FULL_FLAKES
float SampleFlakesSliceLUT(int index)
{
    return UNITY_SAMPLE_TEX2D_LOD(_FullFlakesSliceLUT, float2((index+0.5)/64.0, 0), 0).r * 255.0;
}

float3 SampleFlakesSlice(int sliceBase, int sliceOffset, float2 uv, float2 duvdx, float2 duvdy)
{
    float2 scaleOffset = UNITY_SAMPLE_TEX2D_LOD(_FullFlakesColorScaleOffsetMap, float2((sliceOffset+0.5) / _FullFlakesMaxThetaF, 0), 0).xy;
    float3 rawFlake = UNITY_SAMPLE_TEX2DARRAY_GRAD(_FullFlakesColorMap, float3(uv, sliceBase + sliceOffset), duvdx, duvdy).rgb;

    return rawFlake * scaleOffset.x + scaleOffset.y;
}

float3 SampleFlakesBTF(float NdotH_below, float HdotL_below, float2 uv, float2 duvdx, float2 duvdy)
{
    // f_thetaF/I in [0, pi/2]
    float f_thetaF = acos(clamp(NdotH_below, 0, 1));
    float f_thetaI = acos(clamp(HdotL_below, 0, 1));

    // thetaF sampling defines the angular sampling, i.e. angular flake lifetime
    // int i_angular_sampling = _FullFlakesNumThetaF;
    f_thetaF = (f_thetaF / (0.5 * UNITY_PI) * _FullFlakesNumThetaF) + 0.5;
    f_thetaI = (f_thetaI / (0.5 * UNITY_PI) * _FullFlakesNumThetaI) + 0.5;

    // Bilinear interp indices and weights
    int i_thetaF_low = int(floor(f_thetaF));
    int i_thetaF_high = i_thetaF_low + 1;
    int i_thetaI_low = int(floor(f_thetaI));
    int i_thetaI_high = i_thetaI_low + 1;
    float f_thetaF_w = f_thetaF - float(i_thetaF_low);
    float f_thetaI_w = f_thetaI - float(i_thetaI_low);

    //  to allow lower thetaI samplings while preserving flake lifetime
    // "virtual" thetaI patches are generated by shifting existing ones
    float2 v2_offset_l = float2(0,0);
    float2 v2_offset_h = float2(0,0);
    /*
    if ( flakesNumThetaI < i_angular_sampling )
    {
        v2_offset_l = vec2(rnd_numbers[2*i_thetaI_low],rnd_numbers[2*i_thetaI_low+1]);
        v2_offset_h = vec2(rnd_numbers[2*i_thetaI_high],rnd_numbers[2*i_thetaI_high+1]);
        if (i_thetaI_low%2==1) uv.xy = uv.yx;
        if (i_thetaI_high%2==1) uv.xy = uv.yx;
        //map to the original sampling
        i_thetaI_low = int(floor(i_thetaI_low*float(materialData.flakesNumThetaI)/float(materialData.flakesNumThetaF)));
        i_thetaI_high = int(floor(i_thetaI_high*float(materialData.flakesNumThetaI)/float(materialData.flakesNumThetaF)));
    }
    */

    float3 v3_ll = float3(0, 0, 0);
    float3 v3_lh = float3(0, 0, 0);
    float3 v3_hl = float3(0, 0, 0);
    float3 v3_hh = float3(0, 0, 0);
    // Access flake texture - make sure to stay in the correct slices (no slip over)
    if (i_thetaI_low  < _FullFlakesMaxThetaI)
    {
        float lut_thetaI_low = SampleFlakesSliceLUT(i_thetaI_low);
        float lut_thetaI_low_1 = SampleFlakesSliceLUT(i_thetaI_low+1);
        if (lut_thetaI_low + i_thetaF_low < lut_thetaI_low_1)
        {
            v3_ll = SampleFlakesSlice(lut_thetaI_low, i_thetaF_low, uv, duvdx, duvdy);
        }
        if (lut_thetaI_low + i_thetaF_high < lut_thetaI_low_1)
        {
            v3_hl = SampleFlakesSlice(lut_thetaI_low, i_thetaF_high, uv, duvdx, duvdy);
        }
    }
    if (i_thetaI_high < _FullFlakesMaxThetaI)
    {
        float lut_thetaI_high = SampleFlakesSliceLUT(i_thetaI_high);
        float lut_thetaI_high_1 = SampleFlakesSliceLUT(i_thetaI_high+1);
        if (lut_thetaI_high + i_thetaF_low < lut_thetaI_high_1)
        {
            v3_lh = SampleFlakesSlice(lut_thetaI_high, i_thetaF_low, uv, duvdx, duvdy);
        }
        if (lut_thetaI_high + i_thetaF_high < lut_thetaI_high_1)
        {
            v3_hh = SampleFlakesSlice(lut_thetaI_high, i_thetaF_high, uv, duvdx, duvdy);
        }
    }

    // Bilinear interpolation
    float3 v3_l = lerp(v3_ll, v3_hl, f_thetaF_w);
    float3 v3_h = lerp(v3_lh, v3_hh, f_thetaF_w);
    return lerp(v3_l, v3_h, f_thetaI_w);
}
#endif // USE_FULL_FLAKES



SurfaceData GetSurfaceData(SurfaceInput input)
{
    SurfaceData o = (SurfaceData)0;

    o.uv = input.uvMain;
    o.duvdx = ddx(o.uv);
    o.duvdy = ddy(o.uv);
    ApplyUVTiling(o.uv, o.duvdx, o.duvdy);

    // Flip normal for backfaces
    float3 NormalTS = input.isFrontFace ? float3(0,0,1) : float3(0,0,-1);
    o.NormalWS = TangentToWorld(input, NormalTS);


    float NdotV = dot(o.NormalWS, input.viewDirWS);


    o.DiffuseColor = _DiffuseColor.rgb;
    o.SpecularColor = _SpecularColor.rgb;
#ifdef USE_INTEGRATED_COLOR_LUT_1D
    {
        // Multiply to SpecularColor and Smoothness...

        // _IntegratedColorLUT1D is N x 2 texture!
        // NdotV maps to last pixel
        float lutCoord = NdotV - 0.5 * _IntegratedColorLUT1D_TexelSize.x; // 1/width
        float4 diffuseLUTValue = UNITY_SAMPLE_TEX2D_LOD(_IntegratedColorLUT1D, float2(lutCoord, 0.25), 0);
        float4 specularLUTValue = UNITY_SAMPLE_TEX2D_LOD(_IntegratedColorLUT1D, float2(lutCoord, 0.75), 0);

        o.DiffuseColor *= diffuseLUTValue.rgb;
        o.SpecularColor *= specularLUTValue.rgb;
    }
#endif // USE_INTEGRATED_COLOR_LUT_1D
#ifdef USE_INTEGRATED_COLOR_X_SKY
    {
        float3 reflDir = reflect(-input.viewDirWS, o.NormalWS);

        float arraySlice = (1 - NdotV) * _BRDFColorLUTxSky_ArraySize;
        float alpha = frac(arraySlice);
        int arraySlice_low = floor(arraySlice);
        int arraySlice_high = min(arraySlice_low+1, _BRDFColorLUTxSky_ArraySize-1);

        float3 diffuseColorLow = UNITY_SAMPLE_TEXCUBEARRAY_LOD(_BRDFColorLUTxSkyDiffuse, /*reflDir*/float4(reflDir, arraySlice_low), 0).xyz;
        float3 diffuseColorHigh = UNITY_SAMPLE_TEXCUBEARRAY_LOD(_BRDFColorLUTxSkyDiffuse, /*reflDir*/float4(reflDir, arraySlice_high), 0).xyz;

        float3 specularColorLow = UNITY_SAMPLE_TEXCUBEARRAY_LOD(_BRDFColorLUTxSkySpecular, /*reflDir*/float4(reflDir, arraySlice_low), 0).xyz;
        float3 specularColorHigh = UNITY_SAMPLE_TEXCUBEARRAY_LOD(_BRDFColorLUTxSkySpecular, /*reflDir*/float4(reflDir, arraySlice_high), 0).xyz;

        o.DiffuseColor = lerp(diffuseColorLow, diffuseColorHigh, alpha) * _BRDFColorLUTxSkyDiffuseScale;
        o.SpecularColor = lerp(specularColorLow, specularColorHigh, alpha) * _BRDFColorLUTxSkySpecularScale;
    }
#endif // USE_INTEGRATED_COLOR_X_SKY
#ifdef USE_INTEGRATED_COLOR_X_SKY_SH
    {
        float3 reflDir = reflect(-input.viewDirWS, o.NormalWS);

        // diffuse SH coeffs
        float4 diffuseSHCoeffs[7];
        for (int i = 0; i < 7; ++i)
        {
            // TODO verify UV
            // assert(_BRDFColorLUTxSkyDiffuseSH_TexelSize.w == 7)
            float2 uv = float2(1 - NdotV + 0.5*_BRDFColorLUTxSkyDiffuseSH_TexelSize.x, (i+0.5)/7.0);
            diffuseSHCoeffs[i] = UNITY_SAMPLE_TEX2D_LOD(_BRDFColorLUTxSkyDiffuseSH, uv, 0);
        }
        float3 diffuseColor = SampleSH9(diffuseSHCoeffs, reflDir);

        // specular SH coeffs
        float4 specularSHCoeffs[7];
        for (int i = 0; i < 7; ++i)
        {
            // TODO verify UV
            // assert(_BRDFColorLUTxSkySpecularSH_TexelSize.w == 7)
            float2 uv = float2(1 - NdotV + 0.5*_BRDFColorLUTxSkySpecularSH_TexelSize.x, (i+0.5)/7.0);
            specularSHCoeffs[i] = UNITY_SAMPLE_TEX2D_LOD(_BRDFColorLUTxSkySpecularSH, uv, 0);
        }
        float3 specularColor = SampleSH9(specularSHCoeffs, reflDir);

        o.DiffuseColor = diffuseColor * _BRDFColorLUTxSkyDiffuseScale;
        o.SpecularColor = specularColor * _BRDFColorLUTxSkySpecularScale;
    }
#endif // USE_INTEGRATED_COLOR_X_SKY_SH
#ifdef USE_INTEGRATED_COLOR_X_SKY_SVD
    {
        float3 reflDir = reflect(-input.viewDirWS, o.NormalWS);

        float4 diffuseVector = UNITY_SAMPLE_TEXCUBE_LOD(_BRDFColorLUTxSkyDiffuseCubemap, reflDir, 0);
        // diffuseVector.yzw = 0;
        float3 diffuseColor = _BRDFColorLUTxSkyDiffuseMeanColor;
        for (int i = 0; i < 3; ++i)
        {
            float2 uv = float2( 1 - NdotV + 0.5*_BRDFColorLUTxSkyDiffuseArray_TexelSize.x, (i + 0.5) / 3 );
            diffuseColor[i] += dot(diffuseVector, UNITY_SAMPLE_TEX2D_LOD(_BRDFColorLUTxSkyDiffuseArray, uv, 0));
        }

        float4 specularVector = UNITY_SAMPLE_TEXCUBE_LOD(_BRDFColorLUTxSkySpecularCubemap, reflDir, 0);
        // specularVector.yzw = 0;
        float3 specularColor = _BRDFColorLUTxSkySpecularMeanColor;
        for (int i = 0; i < 3; ++i)
        {
            float2 uv = float2( 1 - NdotV + 0.5*_BRDFColorLUTxSkySpecularArray_TexelSize.x, (i + 0.5) / 3 );
            specularColor[i] += dot(specularVector, UNITY_SAMPLE_TEX2D_LOD(_BRDFColorLUTxSkySpecularArray, uv, 0));
        }

        o.DiffuseColor = diffuseColor * _BRDFColorLUTxSkyDiffuseScale;
        o.SpecularColor = specularColor * _BRDFColorLUTxSkySpecularScale;
    }
#endif // USE_INTEGRATED_COLOR_X_SKY_SVD

    // GGX Fit
    o.GGXSmoothness = _GGXSmoothness;

    // CT Lobes
    o.CTCoeffs = _CTCoeffs;
    o.CTF0s = _CTF0s;
    o.CTSpreads = _CTSpreads;

    // Pre integrated FGD and friends
    float4 preIntegratedFGDValues = _PreIntegratedFGDScale * UNITY_SAMPLE_TEX2D_LOD(_PreIntegratedFGD, float2(NdotV - 0.5*_PreIntegratedFGD_TexelSize.x, 0), 0);
    o.CTFGD = preIntegratedFGDValues.x;
    o.GGXFGD = preIntegratedFGDValues.y;
    o.FlakesFGD = preIntegratedFGDValues.z;
    o.IBLSmoothness = _GGXSmoothness; // preIntegratedFGDValues.w;
    o.DiffuseFGD = _CTCoeffs.w;


    o.FlakesColor = float3(0,0,0);
#ifdef USE_SIMPLE_FLAKES
    o.FlakesColor = _SimpleFlakesColorOffset.rrr + _SimpleFlakesColorScale * UNITY_SAMPLE_TEX2D_GRAD(_SimpleFlakesColorMap, o.uv, o.duvdx, o.duvdy).rgb;
#endif // USE_SIMPLE_FLAKES
#ifdef USE_SIMPLE_FLAKES_3D
    float NdotV_below = NdotV;
#ifdef CLEAR_COAT
    NdotV_below = sqrt(1 - 1.0/Sq(_ClearCoatIOR) * (1 - Sq(NdotV)));
#endif // CLEAR_COAT
    float f_thetaI = acos(clamp(NdotV_below, 0, 1));
    float sliceIndex = (f_thetaI / (0.5 * UNITY_PI) * _FullFlakesNumThetaI) + 0.5;
    float sliceIndex_low = floor(sliceIndex);
    float sliceIndex_high = min(sliceIndex_low+1, _FullFlakesMaxThetaI-1);
    float rawFlakesLerpFactor = sliceIndex - sliceIndex_low;
    float3 rawFlakesValue_low = UNITY_SAMPLE_TEX2DARRAY_GRAD(_SimpleFlakesColorMap3D, float3(o.uv, sliceIndex_low), o.duvdx, o.duvdy).rgb;
    float3 rawFlakesValue_high = UNITY_SAMPLE_TEX2DARRAY_GRAD(_SimpleFlakesColorMap3D, float3(o.uv, sliceIndex_high), o.duvdx, o.duvdy).rgb;
    float3 rawFlakesValue = lerp(rawFlakesValue_low, rawFlakesValue_high, rawFlakesLerpFactor);
    o.FlakesColor = _SimpleFlakesColorOffset3D.rrr + _SimpleFlakesColorScale3D * rawFlakesValue;
#endif // USE_SIMPLE_FLAKES_3D
#ifdef USE_FULL_FLAKES
    float NdotV_below = NdotV;
#ifdef CLEAR_COAT
    NdotV_below = sqrt(1 - 1.0/Sq(_ClearCoatIOR) * (1 - Sq(NdotV)));
#endif // CLEAR_COAT
    float f_thetaI = acos(clamp(NdotV_below, 0, 1));
    float sliceIndex = (f_thetaI / (0.5 * UNITY_PI) * _FullFlakesNumThetaI) + 0.5;
    float sliceIndex_low = floor(sliceIndex);
    float sliceIndex_high = min(sliceIndex_low+1, _FullFlakesMaxThetaI-1);
    float flakesLerpFactor = sliceIndex - sliceIndex_low;
    float3 flakesValue_low = SampleFlakesSlice(SampleFlakesSliceLUT(sliceIndex_low), 0, o.uv, o.duvdx, o.duvdy).rgb;
    float3 flakesValue_high = SampleFlakesSlice(SampleFlakesSliceLUT(sliceIndex_high), 0, o.uv, o.duvdx, o.duvdy).rgb;
    float3 flakesValue = lerp(flakesValue_low, flakesValue_high, flakesLerpFactor);
    float flakesInvStdDev = UNITY_SAMPLE_TEX2D_LOD(_FullFlakesInvStdDevMap, float2((sliceIndex+0.5) / _FullFlakesMaxThetaI, 0), 0).x;
    o.FlakesColor = flakesValue * flakesInvStdDev;
#endif // USE_FULL_FLAKES
#ifdef USE_FLAKES_SMOOTHNESS
    o.FlakesSmoothness = _FlakesSmoothness;
#endif // USE_FLAKES_SMOOTHNESS


#ifdef CLEAR_COAT
    o.ClearCoatF0 = _ClearCoatF0;
    o.ClearCoatF90 = _ClearCoatF90;
    o.ClearCoatIOR = _ClearCoatIOR;
    o.ClearCoatReflectance = ClearCoatReflectance(o.NormalWS, input.viewDirWS, o.ClearCoatF0, o.ClearCoatF90);

    o.DiffuseFGD *= 0.91428571428 * (1.0 - o.ClearCoatReflectance);
    // Attenuate base material for view direction
    //o.CTFGD *= (1.0 - o.ClearCoatReflectance);
    //o.FlakesFGD *= (1.0 - o.ClearCoatReflectance);
#endif // CLEAR_COAT


    o.Occlusion = 1;

    return o;
}

void GetUnityMetaInput(float2 uvMain, float2 uvOcclusion, out float3 diffuseColor, out float3 specularColor, out float smoothness, out float3 emission)
{
    float4 preIntegratedFGDValues = _PreIntegratedFGDScale * UNITY_SAMPLE_TEX2D_LOD(_PreIntegratedFGD, float2(1 - 0.5*_PreIntegratedFGD_TexelSize.x, 0), 0);
    float ctFGD = preIntegratedFGDValues.x;
    float ggxFGD = preIntegratedFGDValues.y;
    // float flakesFGD = preIntegratedFGDValues.z;
    float diffuseFGD = _CTCoeffs.w;

#ifdef CLEAR_COAT
    diffuseFGD *= Sq(0.91428571428);
#endif // CLEAR_COAT

    // Ignore flakes in Meta pass...

    // View direction is undefined here!
    diffuseColor = _DiffuseColor.rgb * diffuseFGD;
    specularColor = _SpecularColor.rgb * ctFGD / ggxFGD;
    smoothness = _GGXSmoothness;
    emission = float3(0,0,0);
}

#endif // AXFCPA2SURFACE_CGINC
